module hunt.http.codec.http.frame.HeadersFrame;

import hunt.http.codec.http.model.MetaData;
import hunt.http.codec.http.frame.Frame;
import hunt.http.codec.http.frame.PriorityFrame;
import hunt.http.codec.http.frame.FrameType;

import std.format;

class HeadersFrame : Frame {
	private int streamId;
	private MetaData metaData;
	private PriorityFrame priority;
	private bool endStream;

	/**
	 * <p>
	 * Creates a new {@code HEADERS} frame with an unspecified stream {@code id}
	 * .
	 * </p>
	 * <p>
	 * The stream {@code id} will be generated by the implementation while
	 * sending this frame to the other peer.
	 * </p>
	 *
	 * @param metaData
	 *            the metadata containing HTTP request information
	 * @param priority
	 *            the PRIORITY frame associated with this HEADERS frame
	 * @param endStream
	 *            whether this frame ends the stream
	 */
	this(MetaData metaData, PriorityFrame priority, bool endStream) {
		this(0, metaData, priority, endStream);
	}

	/**
	 * <p>
	 * Creates a new {@code HEADERS} frame with the specified stream {@code id}.
	 * </p>
	 * <p>
	 * {@code HEADERS} frames with a specific stream {@code id} are typically
	 * used in responses to request {@code HEADERS} frames.
	 * </p>
	 *
	 * @param streamId
	 *            the stream id
	 * @param metaData
	 *            the metadata containing HTTP request/response information
	 * @param priority
	 *            the PRIORITY frame associated with this HEADERS frame
	 * @param endStream
	 *            whether this frame ends the stream
	 */
	this(int streamId, MetaData metaData, PriorityFrame priority, bool endStream) {
		super(FrameType.HEADERS);
		this.streamId = streamId;
		this.metaData = metaData;
		this.priority = priority;
		this.endStream = endStream;
	}

	int getStreamId() {
		return streamId;
	}

	MetaData getMetaData() {
		return metaData;
	}

	PriorityFrame getPriority() {
		return priority;
	}

	bool isEndStream() {
		return endStream;
	}

	override
	string toString() {
		return format("%s#%d{end=%b}", super.toString(), streamId, endStream);
	}
}
